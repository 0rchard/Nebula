// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: storage.proto

#ifndef PROTOBUF_storage_2eproto__INCLUDED
#define PROTOBUF_storage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace neb {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_storage_2eproto();
void protobuf_AssignDesc_storage_2eproto();
void protobuf_ShutdownFile_storage_2eproto();

class Field;
class Record;
class Result;
class Result_DataLocate;
class Storage;
class Storage_DbOperate;
class Storage_DbOperate_Condition;
class Storage_DbOperate_ConditionGroup;
class Storage_DbOperate_OrderBy;
class Storage_RedisOperate;

enum Storage_RedisOperate_OPERATE_TYPE {
  Storage_RedisOperate_OPERATE_TYPE_T_READ = 0,
  Storage_RedisOperate_OPERATE_TYPE_T_WRITE = 1,
  Storage_RedisOperate_OPERATE_TYPE_Storage_RedisOperate_OPERATE_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Storage_RedisOperate_OPERATE_TYPE_Storage_RedisOperate_OPERATE_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Storage_RedisOperate_OPERATE_TYPE_IsValid(int value);
const Storage_RedisOperate_OPERATE_TYPE Storage_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_MIN = Storage_RedisOperate_OPERATE_TYPE_T_READ;
const Storage_RedisOperate_OPERATE_TYPE Storage_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_MAX = Storage_RedisOperate_OPERATE_TYPE_T_WRITE;
const int Storage_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_ARRAYSIZE = Storage_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* Storage_RedisOperate_OPERATE_TYPE_descriptor();
inline const ::std::string& Storage_RedisOperate_OPERATE_TYPE_Name(Storage_RedisOperate_OPERATE_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    Storage_RedisOperate_OPERATE_TYPE_descriptor(), value);
}
inline bool Storage_RedisOperate_OPERATE_TYPE_Parse(
    const ::std::string& name, Storage_RedisOperate_OPERATE_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Storage_RedisOperate_OPERATE_TYPE>(
    Storage_RedisOperate_OPERATE_TYPE_descriptor(), name, value);
}
enum Storage_DbOperate_Condition_E_RELATION {
  Storage_DbOperate_Condition_E_RELATION_EQ = 0,
  Storage_DbOperate_Condition_E_RELATION_NE = 1,
  Storage_DbOperate_Condition_E_RELATION_GT = 2,
  Storage_DbOperate_Condition_E_RELATION_LT = 3,
  Storage_DbOperate_Condition_E_RELATION_GE = 4,
  Storage_DbOperate_Condition_E_RELATION_LE = 5,
  Storage_DbOperate_Condition_E_RELATION_LIKE = 6,
  Storage_DbOperate_Condition_E_RELATION_IN = 7,
  Storage_DbOperate_Condition_E_RELATION_Storage_DbOperate_Condition_E_RELATION_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Storage_DbOperate_Condition_E_RELATION_Storage_DbOperate_Condition_E_RELATION_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Storage_DbOperate_Condition_E_RELATION_IsValid(int value);
const Storage_DbOperate_Condition_E_RELATION Storage_DbOperate_Condition_E_RELATION_E_RELATION_MIN = Storage_DbOperate_Condition_E_RELATION_EQ;
const Storage_DbOperate_Condition_E_RELATION Storage_DbOperate_Condition_E_RELATION_E_RELATION_MAX = Storage_DbOperate_Condition_E_RELATION_IN;
const int Storage_DbOperate_Condition_E_RELATION_E_RELATION_ARRAYSIZE = Storage_DbOperate_Condition_E_RELATION_E_RELATION_MAX + 1;

const ::google::protobuf::EnumDescriptor* Storage_DbOperate_Condition_E_RELATION_descriptor();
inline const ::std::string& Storage_DbOperate_Condition_E_RELATION_Name(Storage_DbOperate_Condition_E_RELATION value) {
  return ::google::protobuf::internal::NameOfEnum(
    Storage_DbOperate_Condition_E_RELATION_descriptor(), value);
}
inline bool Storage_DbOperate_Condition_E_RELATION_Parse(
    const ::std::string& name, Storage_DbOperate_Condition_E_RELATION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Storage_DbOperate_Condition_E_RELATION>(
    Storage_DbOperate_Condition_E_RELATION_descriptor(), name, value);
}
enum Storage_DbOperate_ConditionGroup_E_RELATION {
  Storage_DbOperate_ConditionGroup_E_RELATION_AND = 0,
  Storage_DbOperate_ConditionGroup_E_RELATION_OR = 1,
  Storage_DbOperate_ConditionGroup_E_RELATION_Storage_DbOperate_ConditionGroup_E_RELATION_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Storage_DbOperate_ConditionGroup_E_RELATION_Storage_DbOperate_ConditionGroup_E_RELATION_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Storage_DbOperate_ConditionGroup_E_RELATION_IsValid(int value);
const Storage_DbOperate_ConditionGroup_E_RELATION Storage_DbOperate_ConditionGroup_E_RELATION_E_RELATION_MIN = Storage_DbOperate_ConditionGroup_E_RELATION_AND;
const Storage_DbOperate_ConditionGroup_E_RELATION Storage_DbOperate_ConditionGroup_E_RELATION_E_RELATION_MAX = Storage_DbOperate_ConditionGroup_E_RELATION_OR;
const int Storage_DbOperate_ConditionGroup_E_RELATION_E_RELATION_ARRAYSIZE = Storage_DbOperate_ConditionGroup_E_RELATION_E_RELATION_MAX + 1;

const ::google::protobuf::EnumDescriptor* Storage_DbOperate_ConditionGroup_E_RELATION_descriptor();
inline const ::std::string& Storage_DbOperate_ConditionGroup_E_RELATION_Name(Storage_DbOperate_ConditionGroup_E_RELATION value) {
  return ::google::protobuf::internal::NameOfEnum(
    Storage_DbOperate_ConditionGroup_E_RELATION_descriptor(), value);
}
inline bool Storage_DbOperate_ConditionGroup_E_RELATION_Parse(
    const ::std::string& name, Storage_DbOperate_ConditionGroup_E_RELATION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Storage_DbOperate_ConditionGroup_E_RELATION>(
    Storage_DbOperate_ConditionGroup_E_RELATION_descriptor(), name, value);
}
enum Storage_DbOperate_OrderBy_E_RELATION {
  Storage_DbOperate_OrderBy_E_RELATION_ASC = 0,
  Storage_DbOperate_OrderBy_E_RELATION_DESC = 1,
  Storage_DbOperate_OrderBy_E_RELATION_Storage_DbOperate_OrderBy_E_RELATION_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Storage_DbOperate_OrderBy_E_RELATION_Storage_DbOperate_OrderBy_E_RELATION_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Storage_DbOperate_OrderBy_E_RELATION_IsValid(int value);
const Storage_DbOperate_OrderBy_E_RELATION Storage_DbOperate_OrderBy_E_RELATION_E_RELATION_MIN = Storage_DbOperate_OrderBy_E_RELATION_ASC;
const Storage_DbOperate_OrderBy_E_RELATION Storage_DbOperate_OrderBy_E_RELATION_E_RELATION_MAX = Storage_DbOperate_OrderBy_E_RELATION_DESC;
const int Storage_DbOperate_OrderBy_E_RELATION_E_RELATION_ARRAYSIZE = Storage_DbOperate_OrderBy_E_RELATION_E_RELATION_MAX + 1;

const ::google::protobuf::EnumDescriptor* Storage_DbOperate_OrderBy_E_RELATION_descriptor();
inline const ::std::string& Storage_DbOperate_OrderBy_E_RELATION_Name(Storage_DbOperate_OrderBy_E_RELATION value) {
  return ::google::protobuf::internal::NameOfEnum(
    Storage_DbOperate_OrderBy_E_RELATION_descriptor(), value);
}
inline bool Storage_DbOperate_OrderBy_E_RELATION_Parse(
    const ::std::string& name, Storage_DbOperate_OrderBy_E_RELATION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Storage_DbOperate_OrderBy_E_RELATION>(
    Storage_DbOperate_OrderBy_E_RELATION_descriptor(), name, value);
}
enum Storage_DbOperate_E_QUERY_TYPE {
  Storage_DbOperate_E_QUERY_TYPE_SELECT = 0,
  Storage_DbOperate_E_QUERY_TYPE_INSERT = 1,
  Storage_DbOperate_E_QUERY_TYPE_INSERT_IGNORE = 2,
  Storage_DbOperate_E_QUERY_TYPE_UPDATE = 3,
  Storage_DbOperate_E_QUERY_TYPE_REPLACE = 4,
  Storage_DbOperate_E_QUERY_TYPE_DELETE = 5,
  Storage_DbOperate_E_QUERY_TYPE_Storage_DbOperate_E_QUERY_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Storage_DbOperate_E_QUERY_TYPE_Storage_DbOperate_E_QUERY_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Storage_DbOperate_E_QUERY_TYPE_IsValid(int value);
const Storage_DbOperate_E_QUERY_TYPE Storage_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_MIN = Storage_DbOperate_E_QUERY_TYPE_SELECT;
const Storage_DbOperate_E_QUERY_TYPE Storage_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_MAX = Storage_DbOperate_E_QUERY_TYPE_DELETE;
const int Storage_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_ARRAYSIZE = Storage_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* Storage_DbOperate_E_QUERY_TYPE_descriptor();
inline const ::std::string& Storage_DbOperate_E_QUERY_TYPE_Name(Storage_DbOperate_E_QUERY_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    Storage_DbOperate_E_QUERY_TYPE_descriptor(), value);
}
inline bool Storage_DbOperate_E_QUERY_TYPE_Parse(
    const ::std::string& name, Storage_DbOperate_E_QUERY_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Storage_DbOperate_E_QUERY_TYPE>(
    Storage_DbOperate_E_QUERY_TYPE_descriptor(), name, value);
}
enum Result_E_RESULT_FROM {
  Result_E_RESULT_FROM_FROM_DB = 0,
  Result_E_RESULT_FROM_FROM_REDIS = 1,
  Result_E_RESULT_FROM_Result_E_RESULT_FROM_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Result_E_RESULT_FROM_Result_E_RESULT_FROM_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Result_E_RESULT_FROM_IsValid(int value);
const Result_E_RESULT_FROM Result_E_RESULT_FROM_E_RESULT_FROM_MIN = Result_E_RESULT_FROM_FROM_DB;
const Result_E_RESULT_FROM Result_E_RESULT_FROM_E_RESULT_FROM_MAX = Result_E_RESULT_FROM_FROM_REDIS;
const int Result_E_RESULT_FROM_E_RESULT_FROM_ARRAYSIZE = Result_E_RESULT_FROM_E_RESULT_FROM_MAX + 1;

const ::google::protobuf::EnumDescriptor* Result_E_RESULT_FROM_descriptor();
inline const ::std::string& Result_E_RESULT_FROM_Name(Result_E_RESULT_FROM value) {
  return ::google::protobuf::internal::NameOfEnum(
    Result_E_RESULT_FROM_descriptor(), value);
}
inline bool Result_E_RESULT_FROM_Parse(
    const ::std::string& name, Result_E_RESULT_FROM* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Result_E_RESULT_FROM>(
    Result_E_RESULT_FROM_descriptor(), name, value);
}
enum E_COL_TYPE {
  STRING = 0,
  INT = 1,
  BIGINT = 2,
  FLOAT = 3,
  DOUBLE = 4,
  E_COL_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  E_COL_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool E_COL_TYPE_IsValid(int value);
const E_COL_TYPE E_COL_TYPE_MIN = STRING;
const E_COL_TYPE E_COL_TYPE_MAX = DOUBLE;
const int E_COL_TYPE_ARRAYSIZE = E_COL_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* E_COL_TYPE_descriptor();
inline const ::std::string& E_COL_TYPE_Name(E_COL_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    E_COL_TYPE_descriptor(), value);
}
inline bool E_COL_TYPE_Parse(
    const ::std::string& name, E_COL_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<E_COL_TYPE>(
    E_COL_TYPE_descriptor(), name, value);
}
// ===================================================================

class Storage_RedisOperate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:neb.Storage.RedisOperate) */ {
 public:
  Storage_RedisOperate();
  virtual ~Storage_RedisOperate();

  Storage_RedisOperate(const Storage_RedisOperate& from);

  inline Storage_RedisOperate& operator=(const Storage_RedisOperate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Storage_RedisOperate& default_instance();

  void Swap(Storage_RedisOperate* other);

  // implements Message ----------------------------------------------

  inline Storage_RedisOperate* New() const { return New(NULL); }

  Storage_RedisOperate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Storage_RedisOperate& from);
  void MergeFrom(const Storage_RedisOperate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Storage_RedisOperate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Storage_RedisOperate_OPERATE_TYPE OPERATE_TYPE;
  static const OPERATE_TYPE T_READ =
    Storage_RedisOperate_OPERATE_TYPE_T_READ;
  static const OPERATE_TYPE T_WRITE =
    Storage_RedisOperate_OPERATE_TYPE_T_WRITE;
  static inline bool OPERATE_TYPE_IsValid(int value) {
    return Storage_RedisOperate_OPERATE_TYPE_IsValid(value);
  }
  static const OPERATE_TYPE OPERATE_TYPE_MIN =
    Storage_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_MIN;
  static const OPERATE_TYPE OPERATE_TYPE_MAX =
    Storage_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_MAX;
  static const int OPERATE_TYPE_ARRAYSIZE =
    Storage_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OPERATE_TYPE_descriptor() {
    return Storage_RedisOperate_OPERATE_TYPE_descriptor();
  }
  static inline const ::std::string& OPERATE_TYPE_Name(OPERATE_TYPE value) {
    return Storage_RedisOperate_OPERATE_TYPE_Name(value);
  }
  static inline bool OPERATE_TYPE_Parse(const ::std::string& name,
      OPERATE_TYPE* value) {
    return Storage_RedisOperate_OPERATE_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bytes key_name = 1;
  void clear_key_name();
  static const int kKeyNameFieldNumber = 1;
  const ::std::string& key_name() const;
  void set_key_name(const ::std::string& value);
  void set_key_name(const char* value);
  void set_key_name(const void* value, size_t size);
  ::std::string* mutable_key_name();
  ::std::string* release_key_name();
  void set_allocated_key_name(::std::string* key_name);

  // optional string redis_cmd_read = 2;
  void clear_redis_cmd_read();
  static const int kRedisCmdReadFieldNumber = 2;
  const ::std::string& redis_cmd_read() const;
  void set_redis_cmd_read(const ::std::string& value);
  void set_redis_cmd_read(const char* value);
  void set_redis_cmd_read(const char* value, size_t size);
  ::std::string* mutable_redis_cmd_read();
  ::std::string* release_redis_cmd_read();
  void set_allocated_redis_cmd_read(::std::string* redis_cmd_read);

  // optional string redis_cmd_write = 3;
  void clear_redis_cmd_write();
  static const int kRedisCmdWriteFieldNumber = 3;
  const ::std::string& redis_cmd_write() const;
  void set_redis_cmd_write(const ::std::string& value);
  void set_redis_cmd_write(const char* value);
  void set_redis_cmd_write(const char* value, size_t size);
  ::std::string* mutable_redis_cmd_write();
  ::std::string* release_redis_cmd_write();
  void set_allocated_redis_cmd_write(::std::string* redis_cmd_write);

  // optional .neb.Storage.RedisOperate.OPERATE_TYPE op_type = 4;
  void clear_op_type();
  static const int kOpTypeFieldNumber = 4;
  ::neb::Storage_RedisOperate_OPERATE_TYPE op_type() const;
  void set_op_type(::neb::Storage_RedisOperate_OPERATE_TYPE value);

  // repeated .neb.Field fields = 5;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 5;
  const ::neb::Field& fields(int index) const;
  ::neb::Field* mutable_fields(int index);
  ::neb::Field* add_fields();
  ::google::protobuf::RepeatedPtrField< ::neb::Field >*
      mutable_fields();
  const ::google::protobuf::RepeatedPtrField< ::neb::Field >&
      fields() const;

  // optional int32 key_ttl = 6;
  void clear_key_ttl();
  static const int kKeyTtlFieldNumber = 6;
  ::google::protobuf::int32 key_ttl() const;
  void set_key_ttl(::google::protobuf::int32 value);

  // optional int32 redis_structure = 7;
  void clear_redis_structure();
  static const int kRedisStructureFieldNumber = 7;
  ::google::protobuf::int32 redis_structure() const;
  void set_redis_structure(::google::protobuf::int32 value);

  // optional int32 data_purpose = 8;
  void clear_data_purpose();
  static const int kDataPurposeFieldNumber = 8;
  ::google::protobuf::int32 data_purpose() const;
  void set_data_purpose(::google::protobuf::int32 value);

  // optional bytes hash_key = 9;
  void clear_hash_key();
  static const int kHashKeyFieldNumber = 9;
  const ::std::string& hash_key() const;
  void set_hash_key(const ::std::string& value);
  void set_hash_key(const char* value);
  void set_hash_key(const void* value, size_t size);
  ::std::string* mutable_hash_key();
  ::std::string* release_hash_key();
  void set_allocated_hash_key(::std::string* hash_key);

  // @@protoc_insertion_point(class_scope:neb.Storage.RedisOperate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr key_name_;
  ::google::protobuf::internal::ArenaStringPtr redis_cmd_read_;
  ::google::protobuf::internal::ArenaStringPtr redis_cmd_write_;
  ::google::protobuf::RepeatedPtrField< ::neb::Field > fields_;
  int op_type_;
  ::google::protobuf::int32 key_ttl_;
  ::google::protobuf::int32 redis_structure_;
  ::google::protobuf::int32 data_purpose_;
  ::google::protobuf::internal::ArenaStringPtr hash_key_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_storage_2eproto();
  friend void protobuf_AssignDesc_storage_2eproto();
  friend void protobuf_ShutdownFile_storage_2eproto();

  void InitAsDefaultInstance();
  static Storage_RedisOperate* default_instance_;
};
// -------------------------------------------------------------------

class Storage_DbOperate_Condition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:neb.Storage.DbOperate.Condition) */ {
 public:
  Storage_DbOperate_Condition();
  virtual ~Storage_DbOperate_Condition();

  Storage_DbOperate_Condition(const Storage_DbOperate_Condition& from);

  inline Storage_DbOperate_Condition& operator=(const Storage_DbOperate_Condition& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Storage_DbOperate_Condition& default_instance();

  void Swap(Storage_DbOperate_Condition* other);

  // implements Message ----------------------------------------------

  inline Storage_DbOperate_Condition* New() const { return New(NULL); }

  Storage_DbOperate_Condition* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Storage_DbOperate_Condition& from);
  void MergeFrom(const Storage_DbOperate_Condition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Storage_DbOperate_Condition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Storage_DbOperate_Condition_E_RELATION E_RELATION;
  static const E_RELATION EQ =
    Storage_DbOperate_Condition_E_RELATION_EQ;
  static const E_RELATION NE =
    Storage_DbOperate_Condition_E_RELATION_NE;
  static const E_RELATION GT =
    Storage_DbOperate_Condition_E_RELATION_GT;
  static const E_RELATION LT =
    Storage_DbOperate_Condition_E_RELATION_LT;
  static const E_RELATION GE =
    Storage_DbOperate_Condition_E_RELATION_GE;
  static const E_RELATION LE =
    Storage_DbOperate_Condition_E_RELATION_LE;
  static const E_RELATION LIKE =
    Storage_DbOperate_Condition_E_RELATION_LIKE;
  static const E_RELATION IN =
    Storage_DbOperate_Condition_E_RELATION_IN;
  static inline bool E_RELATION_IsValid(int value) {
    return Storage_DbOperate_Condition_E_RELATION_IsValid(value);
  }
  static const E_RELATION E_RELATION_MIN =
    Storage_DbOperate_Condition_E_RELATION_E_RELATION_MIN;
  static const E_RELATION E_RELATION_MAX =
    Storage_DbOperate_Condition_E_RELATION_E_RELATION_MAX;
  static const int E_RELATION_ARRAYSIZE =
    Storage_DbOperate_Condition_E_RELATION_E_RELATION_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  E_RELATION_descriptor() {
    return Storage_DbOperate_Condition_E_RELATION_descriptor();
  }
  static inline const ::std::string& E_RELATION_Name(E_RELATION value) {
    return Storage_DbOperate_Condition_E_RELATION_Name(value);
  }
  static inline bool E_RELATION_Parse(const ::std::string& name,
      E_RELATION* value) {
    return Storage_DbOperate_Condition_E_RELATION_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .neb.Storage.DbOperate.Condition.E_RELATION relation = 1;
  void clear_relation();
  static const int kRelationFieldNumber = 1;
  ::neb::Storage_DbOperate_Condition_E_RELATION relation() const;
  void set_relation(::neb::Storage_DbOperate_Condition_E_RELATION value);

  // optional .neb.E_COL_TYPE col_type = 2;
  void clear_col_type();
  static const int kColTypeFieldNumber = 2;
  ::neb::E_COL_TYPE col_type() const;
  void set_col_type(::neb::E_COL_TYPE value);

  // optional string col_name = 3;
  void clear_col_name();
  static const int kColNameFieldNumber = 3;
  const ::std::string& col_name() const;
  void set_col_name(const ::std::string& value);
  void set_col_name(const char* value);
  void set_col_name(const char* value, size_t size);
  ::std::string* mutable_col_name();
  ::std::string* release_col_name();
  void set_allocated_col_name(::std::string* col_name);

  // repeated bytes col_values = 4;
  int col_values_size() const;
  void clear_col_values();
  static const int kColValuesFieldNumber = 4;
  const ::std::string& col_values(int index) const;
  ::std::string* mutable_col_values(int index);
  void set_col_values(int index, const ::std::string& value);
  void set_col_values(int index, const char* value);
  void set_col_values(int index, const void* value, size_t size);
  ::std::string* add_col_values();
  void add_col_values(const ::std::string& value);
  void add_col_values(const char* value);
  void add_col_values(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& col_values() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_col_values();

  // optional string col_name_right = 5;
  void clear_col_name_right();
  static const int kColNameRightFieldNumber = 5;
  const ::std::string& col_name_right() const;
  void set_col_name_right(const ::std::string& value);
  void set_col_name_right(const char* value);
  void set_col_name_right(const char* value, size_t size);
  ::std::string* mutable_col_name_right();
  ::std::string* release_col_name_right();
  void set_allocated_col_name_right(::std::string* col_name_right);

  // @@protoc_insertion_point(class_scope:neb.Storage.DbOperate.Condition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int relation_;
  int col_type_;
  ::google::protobuf::internal::ArenaStringPtr col_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> col_values_;
  ::google::protobuf::internal::ArenaStringPtr col_name_right_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_storage_2eproto();
  friend void protobuf_AssignDesc_storage_2eproto();
  friend void protobuf_ShutdownFile_storage_2eproto();

  void InitAsDefaultInstance();
  static Storage_DbOperate_Condition* default_instance_;
};
// -------------------------------------------------------------------

class Storage_DbOperate_ConditionGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:neb.Storage.DbOperate.ConditionGroup) */ {
 public:
  Storage_DbOperate_ConditionGroup();
  virtual ~Storage_DbOperate_ConditionGroup();

  Storage_DbOperate_ConditionGroup(const Storage_DbOperate_ConditionGroup& from);

  inline Storage_DbOperate_ConditionGroup& operator=(const Storage_DbOperate_ConditionGroup& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Storage_DbOperate_ConditionGroup& default_instance();

  void Swap(Storage_DbOperate_ConditionGroup* other);

  // implements Message ----------------------------------------------

  inline Storage_DbOperate_ConditionGroup* New() const { return New(NULL); }

  Storage_DbOperate_ConditionGroup* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Storage_DbOperate_ConditionGroup& from);
  void MergeFrom(const Storage_DbOperate_ConditionGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Storage_DbOperate_ConditionGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Storage_DbOperate_ConditionGroup_E_RELATION E_RELATION;
  static const E_RELATION AND =
    Storage_DbOperate_ConditionGroup_E_RELATION_AND;
  static const E_RELATION OR =
    Storage_DbOperate_ConditionGroup_E_RELATION_OR;
  static inline bool E_RELATION_IsValid(int value) {
    return Storage_DbOperate_ConditionGroup_E_RELATION_IsValid(value);
  }
  static const E_RELATION E_RELATION_MIN =
    Storage_DbOperate_ConditionGroup_E_RELATION_E_RELATION_MIN;
  static const E_RELATION E_RELATION_MAX =
    Storage_DbOperate_ConditionGroup_E_RELATION_E_RELATION_MAX;
  static const int E_RELATION_ARRAYSIZE =
    Storage_DbOperate_ConditionGroup_E_RELATION_E_RELATION_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  E_RELATION_descriptor() {
    return Storage_DbOperate_ConditionGroup_E_RELATION_descriptor();
  }
  static inline const ::std::string& E_RELATION_Name(E_RELATION value) {
    return Storage_DbOperate_ConditionGroup_E_RELATION_Name(value);
  }
  static inline bool E_RELATION_Parse(const ::std::string& name,
      E_RELATION* value) {
    return Storage_DbOperate_ConditionGroup_E_RELATION_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .neb.Storage.DbOperate.ConditionGroup.E_RELATION relation = 1;
  void clear_relation();
  static const int kRelationFieldNumber = 1;
  ::neb::Storage_DbOperate_ConditionGroup_E_RELATION relation() const;
  void set_relation(::neb::Storage_DbOperate_ConditionGroup_E_RELATION value);

  // repeated .neb.Storage.DbOperate.Condition condition = 2;
  int condition_size() const;
  void clear_condition();
  static const int kConditionFieldNumber = 2;
  const ::neb::Storage_DbOperate_Condition& condition(int index) const;
  ::neb::Storage_DbOperate_Condition* mutable_condition(int index);
  ::neb::Storage_DbOperate_Condition* add_condition();
  ::google::protobuf::RepeatedPtrField< ::neb::Storage_DbOperate_Condition >*
      mutable_condition();
  const ::google::protobuf::RepeatedPtrField< ::neb::Storage_DbOperate_Condition >&
      condition() const;

  // @@protoc_insertion_point(class_scope:neb.Storage.DbOperate.ConditionGroup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::neb::Storage_DbOperate_Condition > condition_;
  int relation_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_storage_2eproto();
  friend void protobuf_AssignDesc_storage_2eproto();
  friend void protobuf_ShutdownFile_storage_2eproto();

  void InitAsDefaultInstance();
  static Storage_DbOperate_ConditionGroup* default_instance_;
};
// -------------------------------------------------------------------

class Storage_DbOperate_OrderBy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:neb.Storage.DbOperate.OrderBy) */ {
 public:
  Storage_DbOperate_OrderBy();
  virtual ~Storage_DbOperate_OrderBy();

  Storage_DbOperate_OrderBy(const Storage_DbOperate_OrderBy& from);

  inline Storage_DbOperate_OrderBy& operator=(const Storage_DbOperate_OrderBy& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Storage_DbOperate_OrderBy& default_instance();

  void Swap(Storage_DbOperate_OrderBy* other);

  // implements Message ----------------------------------------------

  inline Storage_DbOperate_OrderBy* New() const { return New(NULL); }

  Storage_DbOperate_OrderBy* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Storage_DbOperate_OrderBy& from);
  void MergeFrom(const Storage_DbOperate_OrderBy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Storage_DbOperate_OrderBy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Storage_DbOperate_OrderBy_E_RELATION E_RELATION;
  static const E_RELATION ASC =
    Storage_DbOperate_OrderBy_E_RELATION_ASC;
  static const E_RELATION DESC =
    Storage_DbOperate_OrderBy_E_RELATION_DESC;
  static inline bool E_RELATION_IsValid(int value) {
    return Storage_DbOperate_OrderBy_E_RELATION_IsValid(value);
  }
  static const E_RELATION E_RELATION_MIN =
    Storage_DbOperate_OrderBy_E_RELATION_E_RELATION_MIN;
  static const E_RELATION E_RELATION_MAX =
    Storage_DbOperate_OrderBy_E_RELATION_E_RELATION_MAX;
  static const int E_RELATION_ARRAYSIZE =
    Storage_DbOperate_OrderBy_E_RELATION_E_RELATION_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  E_RELATION_descriptor() {
    return Storage_DbOperate_OrderBy_E_RELATION_descriptor();
  }
  static inline const ::std::string& E_RELATION_Name(E_RELATION value) {
    return Storage_DbOperate_OrderBy_E_RELATION_Name(value);
  }
  static inline bool E_RELATION_Parse(const ::std::string& name,
      E_RELATION* value) {
    return Storage_DbOperate_OrderBy_E_RELATION_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .neb.Storage.DbOperate.OrderBy.E_RELATION relation = 1;
  void clear_relation();
  static const int kRelationFieldNumber = 1;
  ::neb::Storage_DbOperate_OrderBy_E_RELATION relation() const;
  void set_relation(::neb::Storage_DbOperate_OrderBy_E_RELATION value);

  // optional string col_name = 2;
  void clear_col_name();
  static const int kColNameFieldNumber = 2;
  const ::std::string& col_name() const;
  void set_col_name(const ::std::string& value);
  void set_col_name(const char* value);
  void set_col_name(const char* value, size_t size);
  ::std::string* mutable_col_name();
  ::std::string* release_col_name();
  void set_allocated_col_name(::std::string* col_name);

  // @@protoc_insertion_point(class_scope:neb.Storage.DbOperate.OrderBy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr col_name_;
  int relation_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_storage_2eproto();
  friend void protobuf_AssignDesc_storage_2eproto();
  friend void protobuf_ShutdownFile_storage_2eproto();

  void InitAsDefaultInstance();
  static Storage_DbOperate_OrderBy* default_instance_;
};
// -------------------------------------------------------------------

class Storage_DbOperate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:neb.Storage.DbOperate) */ {
 public:
  Storage_DbOperate();
  virtual ~Storage_DbOperate();

  Storage_DbOperate(const Storage_DbOperate& from);

  inline Storage_DbOperate& operator=(const Storage_DbOperate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Storage_DbOperate& default_instance();

  void Swap(Storage_DbOperate* other);

  // implements Message ----------------------------------------------

  inline Storage_DbOperate* New() const { return New(NULL); }

  Storage_DbOperate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Storage_DbOperate& from);
  void MergeFrom(const Storage_DbOperate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Storage_DbOperate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Storage_DbOperate_Condition Condition;
  typedef Storage_DbOperate_ConditionGroup ConditionGroup;
  typedef Storage_DbOperate_OrderBy OrderBy;

  typedef Storage_DbOperate_E_QUERY_TYPE E_QUERY_TYPE;
  static const E_QUERY_TYPE SELECT =
    Storage_DbOperate_E_QUERY_TYPE_SELECT;
  static const E_QUERY_TYPE INSERT =
    Storage_DbOperate_E_QUERY_TYPE_INSERT;
  static const E_QUERY_TYPE INSERT_IGNORE =
    Storage_DbOperate_E_QUERY_TYPE_INSERT_IGNORE;
  static const E_QUERY_TYPE UPDATE =
    Storage_DbOperate_E_QUERY_TYPE_UPDATE;
  static const E_QUERY_TYPE REPLACE =
    Storage_DbOperate_E_QUERY_TYPE_REPLACE;
  static const E_QUERY_TYPE DELETE =
    Storage_DbOperate_E_QUERY_TYPE_DELETE;
  static inline bool E_QUERY_TYPE_IsValid(int value) {
    return Storage_DbOperate_E_QUERY_TYPE_IsValid(value);
  }
  static const E_QUERY_TYPE E_QUERY_TYPE_MIN =
    Storage_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_MIN;
  static const E_QUERY_TYPE E_QUERY_TYPE_MAX =
    Storage_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_MAX;
  static const int E_QUERY_TYPE_ARRAYSIZE =
    Storage_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  E_QUERY_TYPE_descriptor() {
    return Storage_DbOperate_E_QUERY_TYPE_descriptor();
  }
  static inline const ::std::string& E_QUERY_TYPE_Name(E_QUERY_TYPE value) {
    return Storage_DbOperate_E_QUERY_TYPE_Name(value);
  }
  static inline bool E_QUERY_TYPE_Parse(const ::std::string& name,
      E_QUERY_TYPE* value) {
    return Storage_DbOperate_E_QUERY_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .neb.Storage.DbOperate.E_QUERY_TYPE query_type = 1;
  void clear_query_type();
  static const int kQueryTypeFieldNumber = 1;
  ::neb::Storage_DbOperate_E_QUERY_TYPE query_type() const;
  void set_query_type(::neb::Storage_DbOperate_E_QUERY_TYPE value);

  // optional string table_name = 2;
  void clear_table_name();
  static const int kTableNameFieldNumber = 2;
  const ::std::string& table_name() const;
  void set_table_name(const ::std::string& value);
  void set_table_name(const char* value);
  void set_table_name(const char* value, size_t size);
  ::std::string* mutable_table_name();
  ::std::string* release_table_name();
  void set_allocated_table_name(::std::string* table_name);

  // repeated .neb.Field fields = 3;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 3;
  const ::neb::Field& fields(int index) const;
  ::neb::Field* mutable_fields(int index);
  ::neb::Field* add_fields();
  ::google::protobuf::RepeatedPtrField< ::neb::Field >*
      mutable_fields();
  const ::google::protobuf::RepeatedPtrField< ::neb::Field >&
      fields() const;

  // repeated .neb.Storage.DbOperate.ConditionGroup conditions = 4;
  int conditions_size() const;
  void clear_conditions();
  static const int kConditionsFieldNumber = 4;
  const ::neb::Storage_DbOperate_ConditionGroup& conditions(int index) const;
  ::neb::Storage_DbOperate_ConditionGroup* mutable_conditions(int index);
  ::neb::Storage_DbOperate_ConditionGroup* add_conditions();
  ::google::protobuf::RepeatedPtrField< ::neb::Storage_DbOperate_ConditionGroup >*
      mutable_conditions();
  const ::google::protobuf::RepeatedPtrField< ::neb::Storage_DbOperate_ConditionGroup >&
      conditions() const;

  // repeated string groupby_col = 5;
  int groupby_col_size() const;
  void clear_groupby_col();
  static const int kGroupbyColFieldNumber = 5;
  const ::std::string& groupby_col(int index) const;
  ::std::string* mutable_groupby_col(int index);
  void set_groupby_col(int index, const ::std::string& value);
  void set_groupby_col(int index, const char* value);
  void set_groupby_col(int index, const char* value, size_t size);
  ::std::string* add_groupby_col();
  void add_groupby_col(const ::std::string& value);
  void add_groupby_col(const char* value);
  void add_groupby_col(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& groupby_col() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_groupby_col();

  // repeated .neb.Storage.DbOperate.OrderBy orderby_col = 6;
  int orderby_col_size() const;
  void clear_orderby_col();
  static const int kOrderbyColFieldNumber = 6;
  const ::neb::Storage_DbOperate_OrderBy& orderby_col(int index) const;
  ::neb::Storage_DbOperate_OrderBy* mutable_orderby_col(int index);
  ::neb::Storage_DbOperate_OrderBy* add_orderby_col();
  ::google::protobuf::RepeatedPtrField< ::neb::Storage_DbOperate_OrderBy >*
      mutable_orderby_col();
  const ::google::protobuf::RepeatedPtrField< ::neb::Storage_DbOperate_OrderBy >&
      orderby_col() const;

  // optional .neb.Storage.DbOperate.ConditionGroup.E_RELATION group_relation = 7;
  void clear_group_relation();
  static const int kGroupRelationFieldNumber = 7;
  ::neb::Storage_DbOperate_ConditionGroup_E_RELATION group_relation() const;
  void set_group_relation(::neb::Storage_DbOperate_ConditionGroup_E_RELATION value);

  // optional uint32 limit = 8;
  void clear_limit();
  static const int kLimitFieldNumber = 8;
  ::google::protobuf::uint32 limit() const;
  void set_limit(::google::protobuf::uint32 value);

  // optional uint32 limit_from = 9;
  void clear_limit_from();
  static const int kLimitFromFieldNumber = 9;
  ::google::protobuf::uint32 limit_from() const;
  void set_limit_from(::google::protobuf::uint32 value);

  // optional uint32 mod_factor = 10;
  void clear_mod_factor();
  static const int kModFactorFieldNumber = 10;
  ::google::protobuf::uint32 mod_factor() const;
  void set_mod_factor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:neb.Storage.DbOperate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr table_name_;
  ::google::protobuf::RepeatedPtrField< ::neb::Field > fields_;
  ::google::protobuf::RepeatedPtrField< ::neb::Storage_DbOperate_ConditionGroup > conditions_;
  int query_type_;
  int group_relation_;
  ::google::protobuf::RepeatedPtrField< ::std::string> groupby_col_;
  ::google::protobuf::RepeatedPtrField< ::neb::Storage_DbOperate_OrderBy > orderby_col_;
  ::google::protobuf::uint32 limit_;
  ::google::protobuf::uint32 limit_from_;
  ::google::protobuf::uint32 mod_factor_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_storage_2eproto();
  friend void protobuf_AssignDesc_storage_2eproto();
  friend void protobuf_ShutdownFile_storage_2eproto();

  void InitAsDefaultInstance();
  static Storage_DbOperate* default_instance_;
};
// -------------------------------------------------------------------

class Storage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:neb.Storage) */ {
 public:
  Storage();
  virtual ~Storage();

  Storage(const Storage& from);

  inline Storage& operator=(const Storage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Storage& default_instance();

  void Swap(Storage* other);

  // implements Message ----------------------------------------------

  inline Storage* New() const { return New(NULL); }

  Storage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Storage& from);
  void MergeFrom(const Storage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Storage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Storage_RedisOperate RedisOperate;
  typedef Storage_DbOperate DbOperate;

  // accessors -------------------------------------------------------

  // optional uint32 section_factor = 1;
  void clear_section_factor();
  static const int kSectionFactorFieldNumber = 1;
  ::google::protobuf::uint32 section_factor() const;
  void set_section_factor(::google::protobuf::uint32 value);

  // optional .neb.Storage.RedisOperate redis_operate = 2;
  bool has_redis_operate() const;
  void clear_redis_operate();
  static const int kRedisOperateFieldNumber = 2;
  const ::neb::Storage_RedisOperate& redis_operate() const;
  ::neb::Storage_RedisOperate* mutable_redis_operate();
  ::neb::Storage_RedisOperate* release_redis_operate();
  void set_allocated_redis_operate(::neb::Storage_RedisOperate* redis_operate);

  // optional .neb.Storage.DbOperate db_operate = 3;
  bool has_db_operate() const;
  void clear_db_operate();
  static const int kDbOperateFieldNumber = 3;
  const ::neb::Storage_DbOperate& db_operate() const;
  ::neb::Storage_DbOperate* mutable_db_operate();
  ::neb::Storage_DbOperate* release_db_operate();
  void set_allocated_db_operate(::neb::Storage_DbOperate* db_operate);

  // @@protoc_insertion_point(class_scope:neb.Storage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::neb::Storage_RedisOperate* redis_operate_;
  ::neb::Storage_DbOperate* db_operate_;
  ::google::protobuf::uint32 section_factor_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_storage_2eproto();
  friend void protobuf_AssignDesc_storage_2eproto();
  friend void protobuf_ShutdownFile_storage_2eproto();

  void InitAsDefaultInstance();
  static Storage* default_instance_;
};
// -------------------------------------------------------------------

class Record : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:neb.Record) */ {
 public:
  Record();
  virtual ~Record();

  Record(const Record& from);

  inline Record& operator=(const Record& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Record& default_instance();

  void Swap(Record* other);

  // implements Message ----------------------------------------------

  inline Record* New() const { return New(NULL); }

  Record* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Record& from);
  void MergeFrom(const Record& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Record* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .neb.Field field_info = 1;
  int field_info_size() const;
  void clear_field_info();
  static const int kFieldInfoFieldNumber = 1;
  const ::neb::Field& field_info(int index) const;
  ::neb::Field* mutable_field_info(int index);
  ::neb::Field* add_field_info();
  ::google::protobuf::RepeatedPtrField< ::neb::Field >*
      mutable_field_info();
  const ::google::protobuf::RepeatedPtrField< ::neb::Field >&
      field_info() const;

  // @@protoc_insertion_point(class_scope:neb.Record)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::neb::Field > field_info_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_storage_2eproto();
  friend void protobuf_AssignDesc_storage_2eproto();
  friend void protobuf_ShutdownFile_storage_2eproto();

  void InitAsDefaultInstance();
  static Record* default_instance_;
};
// -------------------------------------------------------------------

class Field : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:neb.Field) */ {
 public:
  Field();
  virtual ~Field();

  Field(const Field& from);

  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Field& default_instance();

  void Swap(Field* other);

  // implements Message ----------------------------------------------

  inline Field* New() const { return New(NULL); }

  Field* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Field& from);
  void MergeFrom(const Field& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Field* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string col_name = 1;
  void clear_col_name();
  static const int kColNameFieldNumber = 1;
  const ::std::string& col_name() const;
  void set_col_name(const ::std::string& value);
  void set_col_name(const char* value);
  void set_col_name(const char* value, size_t size);
  ::std::string* mutable_col_name();
  ::std::string* release_col_name();
  void set_allocated_col_name(::std::string* col_name);

  // optional .neb.E_COL_TYPE col_type = 2;
  void clear_col_type();
  static const int kColTypeFieldNumber = 2;
  ::neb::E_COL_TYPE col_type() const;
  void set_col_type(::neb::E_COL_TYPE value);

  // optional bytes col_value = 3;
  void clear_col_value();
  static const int kColValueFieldNumber = 3;
  const ::std::string& col_value() const;
  void set_col_value(const ::std::string& value);
  void set_col_value(const char* value);
  void set_col_value(const void* value, size_t size);
  ::std::string* mutable_col_value();
  ::std::string* release_col_value();
  void set_allocated_col_value(::std::string* col_value);

  // optional string col_as = 4;
  void clear_col_as();
  static const int kColAsFieldNumber = 4;
  const ::std::string& col_as() const;
  void set_col_as(const ::std::string& value);
  void set_col_as(const char* value);
  void set_col_as(const char* value, size_t size);
  ::std::string* mutable_col_as();
  ::std::string* release_col_as();
  void set_allocated_col_as(::std::string* col_as);

  // @@protoc_insertion_point(class_scope:neb.Field)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr col_name_;
  ::google::protobuf::internal::ArenaStringPtr col_value_;
  ::google::protobuf::internal::ArenaStringPtr col_as_;
  int col_type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_storage_2eproto();
  friend void protobuf_AssignDesc_storage_2eproto();
  friend void protobuf_ShutdownFile_storage_2eproto();

  void InitAsDefaultInstance();
  static Field* default_instance_;
};
// -------------------------------------------------------------------

class Result_DataLocate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:neb.Result.DataLocate) */ {
 public:
  Result_DataLocate();
  virtual ~Result_DataLocate();

  Result_DataLocate(const Result_DataLocate& from);

  inline Result_DataLocate& operator=(const Result_DataLocate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Result_DataLocate& default_instance();

  void Swap(Result_DataLocate* other);

  // implements Message ----------------------------------------------

  inline Result_DataLocate* New() const { return New(NULL); }

  Result_DataLocate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Result_DataLocate& from);
  void MergeFrom(const Result_DataLocate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Result_DataLocate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 section_from = 1;
  void clear_section_from();
  static const int kSectionFromFieldNumber = 1;
  ::google::protobuf::uint32 section_from() const;
  void set_section_from(::google::protobuf::uint32 value);

  // optional uint32 section_to = 2;
  void clear_section_to();
  static const int kSectionToFieldNumber = 2;
  ::google::protobuf::uint32 section_to() const;
  void set_section_to(::google::protobuf::uint32 value);

  // optional uint32 hash = 3;
  void clear_hash();
  static const int kHashFieldNumber = 3;
  ::google::protobuf::uint32 hash() const;
  void set_hash(::google::protobuf::uint32 value);

  // optional uint32 divisor = 4;
  void clear_divisor();
  static const int kDivisorFieldNumber = 4;
  ::google::protobuf::uint32 divisor() const;
  void set_divisor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:neb.Result.DataLocate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint32 section_from_;
  ::google::protobuf::uint32 section_to_;
  ::google::protobuf::uint32 hash_;
  ::google::protobuf::uint32 divisor_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_storage_2eproto();
  friend void protobuf_AssignDesc_storage_2eproto();
  friend void protobuf_ShutdownFile_storage_2eproto();

  void InitAsDefaultInstance();
  static Result_DataLocate* default_instance_;
};
// -------------------------------------------------------------------

class Result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:neb.Result) */ {
 public:
  Result();
  virtual ~Result();

  Result(const Result& from);

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Result& default_instance();

  void Swap(Result* other);

  // implements Message ----------------------------------------------

  inline Result* New() const { return New(NULL); }

  Result* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Result& from);
  void MergeFrom(const Result& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Result_DataLocate DataLocate;

  typedef Result_E_RESULT_FROM E_RESULT_FROM;
  static const E_RESULT_FROM FROM_DB =
    Result_E_RESULT_FROM_FROM_DB;
  static const E_RESULT_FROM FROM_REDIS =
    Result_E_RESULT_FROM_FROM_REDIS;
  static inline bool E_RESULT_FROM_IsValid(int value) {
    return Result_E_RESULT_FROM_IsValid(value);
  }
  static const E_RESULT_FROM E_RESULT_FROM_MIN =
    Result_E_RESULT_FROM_E_RESULT_FROM_MIN;
  static const E_RESULT_FROM E_RESULT_FROM_MAX =
    Result_E_RESULT_FROM_E_RESULT_FROM_MAX;
  static const int E_RESULT_FROM_ARRAYSIZE =
    Result_E_RESULT_FROM_E_RESULT_FROM_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  E_RESULT_FROM_descriptor() {
    return Result_E_RESULT_FROM_descriptor();
  }
  static inline const ::std::string& E_RESULT_FROM_Name(E_RESULT_FROM value) {
    return Result_E_RESULT_FROM_Name(value);
  }
  static inline bool E_RESULT_FROM_Parse(const ::std::string& name,
      E_RESULT_FROM* value) {
    return Result_E_RESULT_FROM_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 err_no = 1;
  void clear_code();
  static const int kErrNoFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // optional bytes err_msg = 2;
  void clear_msg();
  static const int kErrMsgFieldNumber = 2;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  void set_msg(const char* value);
  void set_msg(const void* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* err_msg);

  // optional int32 total_count = 3;
  void clear_total_count();
  static const int kTotalCountFieldNumber = 3;
  ::google::protobuf::int32 total_count() const;
  void set_total_count(::google::protobuf::int32 value);

  // optional int32 current_count = 4;
  void clear_current_count();
  static const int kCurrentCountFieldNumber = 4;
  ::google::protobuf::int32 current_count() const;
  void set_current_count(::google::protobuf::int32 value);

  // repeated .neb.Record record_data = 5;
  int record_data_size() const;
  void clear_record_data();
  static const int kRecordDataFieldNumber = 5;
  const ::neb::Record& record_data(int index) const;
  ::neb::Record* mutable_record_data(int index);
  ::neb::Record* add_record_data();
  ::google::protobuf::RepeatedPtrField< ::neb::Record >*
      mutable_record_data();
  const ::google::protobuf::RepeatedPtrField< ::neb::Record >&
      record_data() const;

  // optional int32 from = 6;
  void clear_from();
  static const int kFromFieldNumber = 6;
  ::google::protobuf::int32 from() const;
  void set_from(::google::protobuf::int32 value);

  // optional .neb.Result.DataLocate locate = 7;
  bool has_locate() const;
  void clear_locate();
  static const int kLocateFieldNumber = 7;
  const ::neb::Result_DataLocate& locate() const;
  ::neb::Result_DataLocate* mutable_locate();
  ::neb::Result_DataLocate* release_locate();
  void set_allocated_locate(::neb::Result_DataLocate* locate);

  // @@protoc_insertion_point(class_scope:neb.Result)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr err_msg_;
  ::google::protobuf::int32 err_no_;
  ::google::protobuf::int32 total_count_;
  ::google::protobuf::RepeatedPtrField< ::neb::Record > record_data_;
  ::google::protobuf::int32 current_count_;
  ::google::protobuf::int32 from_;
  ::neb::Result_DataLocate* locate_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_storage_2eproto();
  friend void protobuf_AssignDesc_storage_2eproto();
  friend void protobuf_ShutdownFile_storage_2eproto();

  void InitAsDefaultInstance();
  static Result* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Storage_RedisOperate

// optional bytes key_name = 1;
inline void Storage_RedisOperate::clear_key_name() {
  key_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Storage_RedisOperate::key_name() const {
  // @@protoc_insertion_point(field_get:neb.Storage.RedisOperate.key_name)
  return key_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Storage_RedisOperate::set_key_name(const ::std::string& value) {
  
  key_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Storage.RedisOperate.key_name)
}
inline void Storage_RedisOperate::set_key_name(const char* value) {
  
  key_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Storage.RedisOperate.key_name)
}
inline void Storage_RedisOperate::set_key_name(const void* value, size_t size) {
  
  key_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Storage.RedisOperate.key_name)
}
inline ::std::string* Storage_RedisOperate::mutable_key_name() {
  
  // @@protoc_insertion_point(field_mutable:neb.Storage.RedisOperate.key_name)
  return key_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Storage_RedisOperate::release_key_name() {
  // @@protoc_insertion_point(field_release:neb.Storage.RedisOperate.key_name)
  
  return key_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Storage_RedisOperate::set_allocated_key_name(::std::string* key_name) {
  if (key_name != NULL) {
    
  } else {
    
  }
  key_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key_name);
  // @@protoc_insertion_point(field_set_allocated:neb.Storage.RedisOperate.key_name)
}

// optional string redis_cmd_read = 2;
inline void Storage_RedisOperate::clear_redis_cmd_read() {
  redis_cmd_read_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Storage_RedisOperate::redis_cmd_read() const {
  // @@protoc_insertion_point(field_get:neb.Storage.RedisOperate.redis_cmd_read)
  return redis_cmd_read_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Storage_RedisOperate::set_redis_cmd_read(const ::std::string& value) {
  
  redis_cmd_read_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Storage.RedisOperate.redis_cmd_read)
}
inline void Storage_RedisOperate::set_redis_cmd_read(const char* value) {
  
  redis_cmd_read_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Storage.RedisOperate.redis_cmd_read)
}
inline void Storage_RedisOperate::set_redis_cmd_read(const char* value, size_t size) {
  
  redis_cmd_read_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Storage.RedisOperate.redis_cmd_read)
}
inline ::std::string* Storage_RedisOperate::mutable_redis_cmd_read() {
  
  // @@protoc_insertion_point(field_mutable:neb.Storage.RedisOperate.redis_cmd_read)
  return redis_cmd_read_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Storage_RedisOperate::release_redis_cmd_read() {
  // @@protoc_insertion_point(field_release:neb.Storage.RedisOperate.redis_cmd_read)
  
  return redis_cmd_read_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Storage_RedisOperate::set_allocated_redis_cmd_read(::std::string* redis_cmd_read) {
  if (redis_cmd_read != NULL) {
    
  } else {
    
  }
  redis_cmd_read_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), redis_cmd_read);
  // @@protoc_insertion_point(field_set_allocated:neb.Storage.RedisOperate.redis_cmd_read)
}

// optional string redis_cmd_write = 3;
inline void Storage_RedisOperate::clear_redis_cmd_write() {
  redis_cmd_write_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Storage_RedisOperate::redis_cmd_write() const {
  // @@protoc_insertion_point(field_get:neb.Storage.RedisOperate.redis_cmd_write)
  return redis_cmd_write_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Storage_RedisOperate::set_redis_cmd_write(const ::std::string& value) {
  
  redis_cmd_write_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Storage.RedisOperate.redis_cmd_write)
}
inline void Storage_RedisOperate::set_redis_cmd_write(const char* value) {
  
  redis_cmd_write_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Storage.RedisOperate.redis_cmd_write)
}
inline void Storage_RedisOperate::set_redis_cmd_write(const char* value, size_t size) {
  
  redis_cmd_write_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Storage.RedisOperate.redis_cmd_write)
}
inline ::std::string* Storage_RedisOperate::mutable_redis_cmd_write() {
  
  // @@protoc_insertion_point(field_mutable:neb.Storage.RedisOperate.redis_cmd_write)
  return redis_cmd_write_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Storage_RedisOperate::release_redis_cmd_write() {
  // @@protoc_insertion_point(field_release:neb.Storage.RedisOperate.redis_cmd_write)
  
  return redis_cmd_write_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Storage_RedisOperate::set_allocated_redis_cmd_write(::std::string* redis_cmd_write) {
  if (redis_cmd_write != NULL) {
    
  } else {
    
  }
  redis_cmd_write_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), redis_cmd_write);
  // @@protoc_insertion_point(field_set_allocated:neb.Storage.RedisOperate.redis_cmd_write)
}

// optional .neb.Storage.RedisOperate.OPERATE_TYPE op_type = 4;
inline void Storage_RedisOperate::clear_op_type() {
  op_type_ = 0;
}
inline ::neb::Storage_RedisOperate_OPERATE_TYPE Storage_RedisOperate::op_type() const {
  // @@protoc_insertion_point(field_get:neb.Storage.RedisOperate.op_type)
  return static_cast< ::neb::Storage_RedisOperate_OPERATE_TYPE >(op_type_);
}
inline void Storage_RedisOperate::set_op_type(::neb::Storage_RedisOperate_OPERATE_TYPE value) {
  
  op_type_ = value;
  // @@protoc_insertion_point(field_set:neb.Storage.RedisOperate.op_type)
}

// repeated .neb.Field fields = 5;
inline int Storage_RedisOperate::fields_size() const {
  return fields_.size();
}
inline void Storage_RedisOperate::clear_fields() {
  fields_.Clear();
}
inline const ::neb::Field& Storage_RedisOperate::fields(int index) const {
  // @@protoc_insertion_point(field_get:neb.Storage.RedisOperate.fields)
  return fields_.Get(index);
}
inline ::neb::Field* Storage_RedisOperate::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:neb.Storage.RedisOperate.fields)
  return fields_.Mutable(index);
}
inline ::neb::Field* Storage_RedisOperate::add_fields() {
  // @@protoc_insertion_point(field_add:neb.Storage.RedisOperate.fields)
  return fields_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::neb::Field >*
Storage_RedisOperate::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:neb.Storage.RedisOperate.fields)
  return &fields_;
}
inline const ::google::protobuf::RepeatedPtrField< ::neb::Field >&
Storage_RedisOperate::fields() const {
  // @@protoc_insertion_point(field_list:neb.Storage.RedisOperate.fields)
  return fields_;
}

// optional int32 key_ttl = 6;
inline void Storage_RedisOperate::clear_key_ttl() {
  key_ttl_ = 0;
}
inline ::google::protobuf::int32 Storage_RedisOperate::key_ttl() const {
  // @@protoc_insertion_point(field_get:neb.Storage.RedisOperate.key_ttl)
  return key_ttl_;
}
inline void Storage_RedisOperate::set_key_ttl(::google::protobuf::int32 value) {
  
  key_ttl_ = value;
  // @@protoc_insertion_point(field_set:neb.Storage.RedisOperate.key_ttl)
}

// optional int32 redis_structure = 7;
inline void Storage_RedisOperate::clear_redis_structure() {
  redis_structure_ = 0;
}
inline ::google::protobuf::int32 Storage_RedisOperate::redis_structure() const {
  // @@protoc_insertion_point(field_get:neb.Storage.RedisOperate.redis_structure)
  return redis_structure_;
}
inline void Storage_RedisOperate::set_redis_structure(::google::protobuf::int32 value) {
  
  redis_structure_ = value;
  // @@protoc_insertion_point(field_set:neb.Storage.RedisOperate.redis_structure)
}

// optional int32 data_purpose = 8;
inline void Storage_RedisOperate::clear_data_purpose() {
  data_purpose_ = 0;
}
inline ::google::protobuf::int32 Storage_RedisOperate::data_purpose() const {
  // @@protoc_insertion_point(field_get:neb.Storage.RedisOperate.data_purpose)
  return data_purpose_;
}
inline void Storage_RedisOperate::set_data_purpose(::google::protobuf::int32 value) {
  
  data_purpose_ = value;
  // @@protoc_insertion_point(field_set:neb.Storage.RedisOperate.data_purpose)
}

// optional bytes hash_key = 9;
inline void Storage_RedisOperate::clear_hash_key() {
  hash_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Storage_RedisOperate::hash_key() const {
  // @@protoc_insertion_point(field_get:neb.Storage.RedisOperate.hash_key)
  return hash_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Storage_RedisOperate::set_hash_key(const ::std::string& value) {
  
  hash_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Storage.RedisOperate.hash_key)
}
inline void Storage_RedisOperate::set_hash_key(const char* value) {
  
  hash_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Storage.RedisOperate.hash_key)
}
inline void Storage_RedisOperate::set_hash_key(const void* value, size_t size) {
  
  hash_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Storage.RedisOperate.hash_key)
}
inline ::std::string* Storage_RedisOperate::mutable_hash_key() {
  
  // @@protoc_insertion_point(field_mutable:neb.Storage.RedisOperate.hash_key)
  return hash_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Storage_RedisOperate::release_hash_key() {
  // @@protoc_insertion_point(field_release:neb.Storage.RedisOperate.hash_key)
  
  return hash_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Storage_RedisOperate::set_allocated_hash_key(::std::string* hash_key) {
  if (hash_key != NULL) {
    
  } else {
    
  }
  hash_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash_key);
  // @@protoc_insertion_point(field_set_allocated:neb.Storage.RedisOperate.hash_key)
}

// -------------------------------------------------------------------

// Storage_DbOperate_Condition

// optional .neb.Storage.DbOperate.Condition.E_RELATION relation = 1;
inline void Storage_DbOperate_Condition::clear_relation() {
  relation_ = 0;
}
inline ::neb::Storage_DbOperate_Condition_E_RELATION Storage_DbOperate_Condition::relation() const {
  // @@protoc_insertion_point(field_get:neb.Storage.DbOperate.Condition.relation)
  return static_cast< ::neb::Storage_DbOperate_Condition_E_RELATION >(relation_);
}
inline void Storage_DbOperate_Condition::set_relation(::neb::Storage_DbOperate_Condition_E_RELATION value) {
  
  relation_ = value;
  // @@protoc_insertion_point(field_set:neb.Storage.DbOperate.Condition.relation)
}

// optional .neb.E_COL_TYPE col_type = 2;
inline void Storage_DbOperate_Condition::clear_col_type() {
  col_type_ = 0;
}
inline ::neb::E_COL_TYPE Storage_DbOperate_Condition::col_type() const {
  // @@protoc_insertion_point(field_get:neb.Storage.DbOperate.Condition.col_type)
  return static_cast< ::neb::E_COL_TYPE >(col_type_);
}
inline void Storage_DbOperate_Condition::set_col_type(::neb::E_COL_TYPE value) {
  
  col_type_ = value;
  // @@protoc_insertion_point(field_set:neb.Storage.DbOperate.Condition.col_type)
}

// optional string col_name = 3;
inline void Storage_DbOperate_Condition::clear_col_name() {
  col_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Storage_DbOperate_Condition::col_name() const {
  // @@protoc_insertion_point(field_get:neb.Storage.DbOperate.Condition.col_name)
  return col_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Storage_DbOperate_Condition::set_col_name(const ::std::string& value) {
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Storage.DbOperate.Condition.col_name)
}
inline void Storage_DbOperate_Condition::set_col_name(const char* value) {
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Storage.DbOperate.Condition.col_name)
}
inline void Storage_DbOperate_Condition::set_col_name(const char* value, size_t size) {
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Storage.DbOperate.Condition.col_name)
}
inline ::std::string* Storage_DbOperate_Condition::mutable_col_name() {
  
  // @@protoc_insertion_point(field_mutable:neb.Storage.DbOperate.Condition.col_name)
  return col_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Storage_DbOperate_Condition::release_col_name() {
  // @@protoc_insertion_point(field_release:neb.Storage.DbOperate.Condition.col_name)
  
  return col_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Storage_DbOperate_Condition::set_allocated_col_name(::std::string* col_name) {
  if (col_name != NULL) {
    
  } else {
    
  }
  col_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), col_name);
  // @@protoc_insertion_point(field_set_allocated:neb.Storage.DbOperate.Condition.col_name)
}

// repeated bytes col_values = 4;
inline int Storage_DbOperate_Condition::col_values_size() const {
  return col_values_.size();
}
inline void Storage_DbOperate_Condition::clear_col_values() {
  col_values_.Clear();
}
inline const ::std::string& Storage_DbOperate_Condition::col_values(int index) const {
  // @@protoc_insertion_point(field_get:neb.Storage.DbOperate.Condition.col_values)
  return col_values_.Get(index);
}
inline ::std::string* Storage_DbOperate_Condition::mutable_col_values(int index) {
  // @@protoc_insertion_point(field_mutable:neb.Storage.DbOperate.Condition.col_values)
  return col_values_.Mutable(index);
}
inline void Storage_DbOperate_Condition::set_col_values(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:neb.Storage.DbOperate.Condition.col_values)
  col_values_.Mutable(index)->assign(value);
}
inline void Storage_DbOperate_Condition::set_col_values(int index, const char* value) {
  col_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:neb.Storage.DbOperate.Condition.col_values)
}
inline void Storage_DbOperate_Condition::set_col_values(int index, const void* value, size_t size) {
  col_values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:neb.Storage.DbOperate.Condition.col_values)
}
inline ::std::string* Storage_DbOperate_Condition::add_col_values() {
  // @@protoc_insertion_point(field_add_mutable:neb.Storage.DbOperate.Condition.col_values)
  return col_values_.Add();
}
inline void Storage_DbOperate_Condition::add_col_values(const ::std::string& value) {
  col_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:neb.Storage.DbOperate.Condition.col_values)
}
inline void Storage_DbOperate_Condition::add_col_values(const char* value) {
  col_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:neb.Storage.DbOperate.Condition.col_values)
}
inline void Storage_DbOperate_Condition::add_col_values(const void* value, size_t size) {
  col_values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:neb.Storage.DbOperate.Condition.col_values)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Storage_DbOperate_Condition::col_values() const {
  // @@protoc_insertion_point(field_list:neb.Storage.DbOperate.Condition.col_values)
  return col_values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Storage_DbOperate_Condition::mutable_col_values() {
  // @@protoc_insertion_point(field_mutable_list:neb.Storage.DbOperate.Condition.col_values)
  return &col_values_;
}

// optional string col_name_right = 5;
inline void Storage_DbOperate_Condition::clear_col_name_right() {
  col_name_right_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Storage_DbOperate_Condition::col_name_right() const {
  // @@protoc_insertion_point(field_get:neb.Storage.DbOperate.Condition.col_name_right)
  return col_name_right_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Storage_DbOperate_Condition::set_col_name_right(const ::std::string& value) {
  
  col_name_right_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Storage.DbOperate.Condition.col_name_right)
}
inline void Storage_DbOperate_Condition::set_col_name_right(const char* value) {
  
  col_name_right_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Storage.DbOperate.Condition.col_name_right)
}
inline void Storage_DbOperate_Condition::set_col_name_right(const char* value, size_t size) {
  
  col_name_right_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Storage.DbOperate.Condition.col_name_right)
}
inline ::std::string* Storage_DbOperate_Condition::mutable_col_name_right() {
  
  // @@protoc_insertion_point(field_mutable:neb.Storage.DbOperate.Condition.col_name_right)
  return col_name_right_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Storage_DbOperate_Condition::release_col_name_right() {
  // @@protoc_insertion_point(field_release:neb.Storage.DbOperate.Condition.col_name_right)
  
  return col_name_right_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Storage_DbOperate_Condition::set_allocated_col_name_right(::std::string* col_name_right) {
  if (col_name_right != NULL) {
    
  } else {
    
  }
  col_name_right_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), col_name_right);
  // @@protoc_insertion_point(field_set_allocated:neb.Storage.DbOperate.Condition.col_name_right)
}

// -------------------------------------------------------------------

// Storage_DbOperate_ConditionGroup

// optional .neb.Storage.DbOperate.ConditionGroup.E_RELATION relation = 1;
inline void Storage_DbOperate_ConditionGroup::clear_relation() {
  relation_ = 0;
}
inline ::neb::Storage_DbOperate_ConditionGroup_E_RELATION Storage_DbOperate_ConditionGroup::relation() const {
  // @@protoc_insertion_point(field_get:neb.Storage.DbOperate.ConditionGroup.relation)
  return static_cast< ::neb::Storage_DbOperate_ConditionGroup_E_RELATION >(relation_);
}
inline void Storage_DbOperate_ConditionGroup::set_relation(::neb::Storage_DbOperate_ConditionGroup_E_RELATION value) {
  
  relation_ = value;
  // @@protoc_insertion_point(field_set:neb.Storage.DbOperate.ConditionGroup.relation)
}

// repeated .neb.Storage.DbOperate.Condition condition = 2;
inline int Storage_DbOperate_ConditionGroup::condition_size() const {
  return condition_.size();
}
inline void Storage_DbOperate_ConditionGroup::clear_condition() {
  condition_.Clear();
}
inline const ::neb::Storage_DbOperate_Condition& Storage_DbOperate_ConditionGroup::condition(int index) const {
  // @@protoc_insertion_point(field_get:neb.Storage.DbOperate.ConditionGroup.condition)
  return condition_.Get(index);
}
inline ::neb::Storage_DbOperate_Condition* Storage_DbOperate_ConditionGroup::mutable_condition(int index) {
  // @@protoc_insertion_point(field_mutable:neb.Storage.DbOperate.ConditionGroup.condition)
  return condition_.Mutable(index);
}
inline ::neb::Storage_DbOperate_Condition* Storage_DbOperate_ConditionGroup::add_condition() {
  // @@protoc_insertion_point(field_add:neb.Storage.DbOperate.ConditionGroup.condition)
  return condition_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::neb::Storage_DbOperate_Condition >*
Storage_DbOperate_ConditionGroup::mutable_condition() {
  // @@protoc_insertion_point(field_mutable_list:neb.Storage.DbOperate.ConditionGroup.condition)
  return &condition_;
}
inline const ::google::protobuf::RepeatedPtrField< ::neb::Storage_DbOperate_Condition >&
Storage_DbOperate_ConditionGroup::condition() const {
  // @@protoc_insertion_point(field_list:neb.Storage.DbOperate.ConditionGroup.condition)
  return condition_;
}

// -------------------------------------------------------------------

// Storage_DbOperate_OrderBy

// optional .neb.Storage.DbOperate.OrderBy.E_RELATION relation = 1;
inline void Storage_DbOperate_OrderBy::clear_relation() {
  relation_ = 0;
}
inline ::neb::Storage_DbOperate_OrderBy_E_RELATION Storage_DbOperate_OrderBy::relation() const {
  // @@protoc_insertion_point(field_get:neb.Storage.DbOperate.OrderBy.relation)
  return static_cast< ::neb::Storage_DbOperate_OrderBy_E_RELATION >(relation_);
}
inline void Storage_DbOperate_OrderBy::set_relation(::neb::Storage_DbOperate_OrderBy_E_RELATION value) {
  
  relation_ = value;
  // @@protoc_insertion_point(field_set:neb.Storage.DbOperate.OrderBy.relation)
}

// optional string col_name = 2;
inline void Storage_DbOperate_OrderBy::clear_col_name() {
  col_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Storage_DbOperate_OrderBy::col_name() const {
  // @@protoc_insertion_point(field_get:neb.Storage.DbOperate.OrderBy.col_name)
  return col_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Storage_DbOperate_OrderBy::set_col_name(const ::std::string& value) {
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Storage.DbOperate.OrderBy.col_name)
}
inline void Storage_DbOperate_OrderBy::set_col_name(const char* value) {
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Storage.DbOperate.OrderBy.col_name)
}
inline void Storage_DbOperate_OrderBy::set_col_name(const char* value, size_t size) {
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Storage.DbOperate.OrderBy.col_name)
}
inline ::std::string* Storage_DbOperate_OrderBy::mutable_col_name() {
  
  // @@protoc_insertion_point(field_mutable:neb.Storage.DbOperate.OrderBy.col_name)
  return col_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Storage_DbOperate_OrderBy::release_col_name() {
  // @@protoc_insertion_point(field_release:neb.Storage.DbOperate.OrderBy.col_name)
  
  return col_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Storage_DbOperate_OrderBy::set_allocated_col_name(::std::string* col_name) {
  if (col_name != NULL) {
    
  } else {
    
  }
  col_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), col_name);
  // @@protoc_insertion_point(field_set_allocated:neb.Storage.DbOperate.OrderBy.col_name)
}

// -------------------------------------------------------------------

// Storage_DbOperate

// optional .neb.Storage.DbOperate.E_QUERY_TYPE query_type = 1;
inline void Storage_DbOperate::clear_query_type() {
  query_type_ = 0;
}
inline ::neb::Storage_DbOperate_E_QUERY_TYPE Storage_DbOperate::query_type() const {
  // @@protoc_insertion_point(field_get:neb.Storage.DbOperate.query_type)
  return static_cast< ::neb::Storage_DbOperate_E_QUERY_TYPE >(query_type_);
}
inline void Storage_DbOperate::set_query_type(::neb::Storage_DbOperate_E_QUERY_TYPE value) {
  
  query_type_ = value;
  // @@protoc_insertion_point(field_set:neb.Storage.DbOperate.query_type)
}

// optional string table_name = 2;
inline void Storage_DbOperate::clear_table_name() {
  table_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Storage_DbOperate::table_name() const {
  // @@protoc_insertion_point(field_get:neb.Storage.DbOperate.table_name)
  return table_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Storage_DbOperate::set_table_name(const ::std::string& value) {
  
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Storage.DbOperate.table_name)
}
inline void Storage_DbOperate::set_table_name(const char* value) {
  
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Storage.DbOperate.table_name)
}
inline void Storage_DbOperate::set_table_name(const char* value, size_t size) {
  
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Storage.DbOperate.table_name)
}
inline ::std::string* Storage_DbOperate::mutable_table_name() {
  
  // @@protoc_insertion_point(field_mutable:neb.Storage.DbOperate.table_name)
  return table_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Storage_DbOperate::release_table_name() {
  // @@protoc_insertion_point(field_release:neb.Storage.DbOperate.table_name)
  
  return table_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Storage_DbOperate::set_allocated_table_name(::std::string* table_name) {
  if (table_name != NULL) {
    
  } else {
    
  }
  table_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), table_name);
  // @@protoc_insertion_point(field_set_allocated:neb.Storage.DbOperate.table_name)
}

// repeated .neb.Field fields = 3;
inline int Storage_DbOperate::fields_size() const {
  return fields_.size();
}
inline void Storage_DbOperate::clear_fields() {
  fields_.Clear();
}
inline const ::neb::Field& Storage_DbOperate::fields(int index) const {
  // @@protoc_insertion_point(field_get:neb.Storage.DbOperate.fields)
  return fields_.Get(index);
}
inline ::neb::Field* Storage_DbOperate::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:neb.Storage.DbOperate.fields)
  return fields_.Mutable(index);
}
inline ::neb::Field* Storage_DbOperate::add_fields() {
  // @@protoc_insertion_point(field_add:neb.Storage.DbOperate.fields)
  return fields_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::neb::Field >*
Storage_DbOperate::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:neb.Storage.DbOperate.fields)
  return &fields_;
}
inline const ::google::protobuf::RepeatedPtrField< ::neb::Field >&
Storage_DbOperate::fields() const {
  // @@protoc_insertion_point(field_list:neb.Storage.DbOperate.fields)
  return fields_;
}

// repeated .neb.Storage.DbOperate.ConditionGroup conditions = 4;
inline int Storage_DbOperate::conditions_size() const {
  return conditions_.size();
}
inline void Storage_DbOperate::clear_conditions() {
  conditions_.Clear();
}
inline const ::neb::Storage_DbOperate_ConditionGroup& Storage_DbOperate::conditions(int index) const {
  // @@protoc_insertion_point(field_get:neb.Storage.DbOperate.conditions)
  return conditions_.Get(index);
}
inline ::neb::Storage_DbOperate_ConditionGroup* Storage_DbOperate::mutable_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:neb.Storage.DbOperate.conditions)
  return conditions_.Mutable(index);
}
inline ::neb::Storage_DbOperate_ConditionGroup* Storage_DbOperate::add_conditions() {
  // @@protoc_insertion_point(field_add:neb.Storage.DbOperate.conditions)
  return conditions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::neb::Storage_DbOperate_ConditionGroup >*
Storage_DbOperate::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_list:neb.Storage.DbOperate.conditions)
  return &conditions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::neb::Storage_DbOperate_ConditionGroup >&
Storage_DbOperate::conditions() const {
  // @@protoc_insertion_point(field_list:neb.Storage.DbOperate.conditions)
  return conditions_;
}

// repeated string groupby_col = 5;
inline int Storage_DbOperate::groupby_col_size() const {
  return groupby_col_.size();
}
inline void Storage_DbOperate::clear_groupby_col() {
  groupby_col_.Clear();
}
inline const ::std::string& Storage_DbOperate::groupby_col(int index) const {
  // @@protoc_insertion_point(field_get:neb.Storage.DbOperate.groupby_col)
  return groupby_col_.Get(index);
}
inline ::std::string* Storage_DbOperate::mutable_groupby_col(int index) {
  // @@protoc_insertion_point(field_mutable:neb.Storage.DbOperate.groupby_col)
  return groupby_col_.Mutable(index);
}
inline void Storage_DbOperate::set_groupby_col(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:neb.Storage.DbOperate.groupby_col)
  groupby_col_.Mutable(index)->assign(value);
}
inline void Storage_DbOperate::set_groupby_col(int index, const char* value) {
  groupby_col_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:neb.Storage.DbOperate.groupby_col)
}
inline void Storage_DbOperate::set_groupby_col(int index, const char* value, size_t size) {
  groupby_col_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:neb.Storage.DbOperate.groupby_col)
}
inline ::std::string* Storage_DbOperate::add_groupby_col() {
  // @@protoc_insertion_point(field_add_mutable:neb.Storage.DbOperate.groupby_col)
  return groupby_col_.Add();
}
inline void Storage_DbOperate::add_groupby_col(const ::std::string& value) {
  groupby_col_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:neb.Storage.DbOperate.groupby_col)
}
inline void Storage_DbOperate::add_groupby_col(const char* value) {
  groupby_col_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:neb.Storage.DbOperate.groupby_col)
}
inline void Storage_DbOperate::add_groupby_col(const char* value, size_t size) {
  groupby_col_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:neb.Storage.DbOperate.groupby_col)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Storage_DbOperate::groupby_col() const {
  // @@protoc_insertion_point(field_list:neb.Storage.DbOperate.groupby_col)
  return groupby_col_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Storage_DbOperate::mutable_groupby_col() {
  // @@protoc_insertion_point(field_mutable_list:neb.Storage.DbOperate.groupby_col)
  return &groupby_col_;
}

// repeated .neb.Storage.DbOperate.OrderBy orderby_col = 6;
inline int Storage_DbOperate::orderby_col_size() const {
  return orderby_col_.size();
}
inline void Storage_DbOperate::clear_orderby_col() {
  orderby_col_.Clear();
}
inline const ::neb::Storage_DbOperate_OrderBy& Storage_DbOperate::orderby_col(int index) const {
  // @@protoc_insertion_point(field_get:neb.Storage.DbOperate.orderby_col)
  return orderby_col_.Get(index);
}
inline ::neb::Storage_DbOperate_OrderBy* Storage_DbOperate::mutable_orderby_col(int index) {
  // @@protoc_insertion_point(field_mutable:neb.Storage.DbOperate.orderby_col)
  return orderby_col_.Mutable(index);
}
inline ::neb::Storage_DbOperate_OrderBy* Storage_DbOperate::add_orderby_col() {
  // @@protoc_insertion_point(field_add:neb.Storage.DbOperate.orderby_col)
  return orderby_col_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::neb::Storage_DbOperate_OrderBy >*
Storage_DbOperate::mutable_orderby_col() {
  // @@protoc_insertion_point(field_mutable_list:neb.Storage.DbOperate.orderby_col)
  return &orderby_col_;
}
inline const ::google::protobuf::RepeatedPtrField< ::neb::Storage_DbOperate_OrderBy >&
Storage_DbOperate::orderby_col() const {
  // @@protoc_insertion_point(field_list:neb.Storage.DbOperate.orderby_col)
  return orderby_col_;
}

// optional .neb.Storage.DbOperate.ConditionGroup.E_RELATION group_relation = 7;
inline void Storage_DbOperate::clear_group_relation() {
  group_relation_ = 0;
}
inline ::neb::Storage_DbOperate_ConditionGroup_E_RELATION Storage_DbOperate::group_relation() const {
  // @@protoc_insertion_point(field_get:neb.Storage.DbOperate.group_relation)
  return static_cast< ::neb::Storage_DbOperate_ConditionGroup_E_RELATION >(group_relation_);
}
inline void Storage_DbOperate::set_group_relation(::neb::Storage_DbOperate_ConditionGroup_E_RELATION value) {
  
  group_relation_ = value;
  // @@protoc_insertion_point(field_set:neb.Storage.DbOperate.group_relation)
}

// optional uint32 limit = 8;
inline void Storage_DbOperate::clear_limit() {
  limit_ = 0u;
}
inline ::google::protobuf::uint32 Storage_DbOperate::limit() const {
  // @@protoc_insertion_point(field_get:neb.Storage.DbOperate.limit)
  return limit_;
}
inline void Storage_DbOperate::set_limit(::google::protobuf::uint32 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:neb.Storage.DbOperate.limit)
}

// optional uint32 limit_from = 9;
inline void Storage_DbOperate::clear_limit_from() {
  limit_from_ = 0u;
}
inline ::google::protobuf::uint32 Storage_DbOperate::limit_from() const {
  // @@protoc_insertion_point(field_get:neb.Storage.DbOperate.limit_from)
  return limit_from_;
}
inline void Storage_DbOperate::set_limit_from(::google::protobuf::uint32 value) {
  
  limit_from_ = value;
  // @@protoc_insertion_point(field_set:neb.Storage.DbOperate.limit_from)
}

// optional uint32 mod_factor = 10;
inline void Storage_DbOperate::clear_mod_factor() {
  mod_factor_ = 0u;
}
inline ::google::protobuf::uint32 Storage_DbOperate::mod_factor() const {
  // @@protoc_insertion_point(field_get:neb.Storage.DbOperate.mod_factor)
  return mod_factor_;
}
inline void Storage_DbOperate::set_mod_factor(::google::protobuf::uint32 value) {
  
  mod_factor_ = value;
  // @@protoc_insertion_point(field_set:neb.Storage.DbOperate.mod_factor)
}

// -------------------------------------------------------------------

// Storage

// optional uint32 section_factor = 1;
inline void Storage::clear_section_factor() {
  section_factor_ = 0u;
}
inline ::google::protobuf::uint32 Storage::section_factor() const {
  // @@protoc_insertion_point(field_get:neb.Storage.section_factor)
  return section_factor_;
}
inline void Storage::set_section_factor(::google::protobuf::uint32 value) {
  
  section_factor_ = value;
  // @@protoc_insertion_point(field_set:neb.Storage.section_factor)
}

// optional .neb.Storage.RedisOperate redis_operate = 2;
inline bool Storage::has_redis_operate() const {
  return !_is_default_instance_ && redis_operate_ != NULL;
}
inline void Storage::clear_redis_operate() {
  if (GetArenaNoVirtual() == NULL && redis_operate_ != NULL) delete redis_operate_;
  redis_operate_ = NULL;
}
inline const ::neb::Storage_RedisOperate& Storage::redis_operate() const {
  // @@protoc_insertion_point(field_get:neb.Storage.redis_operate)
  return redis_operate_ != NULL ? *redis_operate_ : *default_instance_->redis_operate_;
}
inline ::neb::Storage_RedisOperate* Storage::mutable_redis_operate() {
  
  if (redis_operate_ == NULL) {
    redis_operate_ = new ::neb::Storage_RedisOperate;
  }
  // @@protoc_insertion_point(field_mutable:neb.Storage.redis_operate)
  return redis_operate_;
}
inline ::neb::Storage_RedisOperate* Storage::release_redis_operate() {
  // @@protoc_insertion_point(field_release:neb.Storage.redis_operate)
  
  ::neb::Storage_RedisOperate* temp = redis_operate_;
  redis_operate_ = NULL;
  return temp;
}
inline void Storage::set_allocated_redis_operate(::neb::Storage_RedisOperate* redis_operate) {
  delete redis_operate_;
  redis_operate_ = redis_operate;
  if (redis_operate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:neb.Storage.redis_operate)
}

// optional .neb.Storage.DbOperate db_operate = 3;
inline bool Storage::has_db_operate() const {
  return !_is_default_instance_ && db_operate_ != NULL;
}
inline void Storage::clear_db_operate() {
  if (GetArenaNoVirtual() == NULL && db_operate_ != NULL) delete db_operate_;
  db_operate_ = NULL;
}
inline const ::neb::Storage_DbOperate& Storage::db_operate() const {
  // @@protoc_insertion_point(field_get:neb.Storage.db_operate)
  return db_operate_ != NULL ? *db_operate_ : *default_instance_->db_operate_;
}
inline ::neb::Storage_DbOperate* Storage::mutable_db_operate() {
  
  if (db_operate_ == NULL) {
    db_operate_ = new ::neb::Storage_DbOperate;
  }
  // @@protoc_insertion_point(field_mutable:neb.Storage.db_operate)
  return db_operate_;
}
inline ::neb::Storage_DbOperate* Storage::release_db_operate() {
  // @@protoc_insertion_point(field_release:neb.Storage.db_operate)
  
  ::neb::Storage_DbOperate* temp = db_operate_;
  db_operate_ = NULL;
  return temp;
}
inline void Storage::set_allocated_db_operate(::neb::Storage_DbOperate* db_operate) {
  delete db_operate_;
  db_operate_ = db_operate;
  if (db_operate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:neb.Storage.db_operate)
}

// -------------------------------------------------------------------

// Record

// repeated .neb.Field field_info = 1;
inline int Record::field_info_size() const {
  return field_info_.size();
}
inline void Record::clear_field_info() {
  field_info_.Clear();
}
inline const ::neb::Field& Record::field_info(int index) const {
  // @@protoc_insertion_point(field_get:neb.Record.field_info)
  return field_info_.Get(index);
}
inline ::neb::Field* Record::mutable_field_info(int index) {
  // @@protoc_insertion_point(field_mutable:neb.Record.field_info)
  return field_info_.Mutable(index);
}
inline ::neb::Field* Record::add_field_info() {
  // @@protoc_insertion_point(field_add:neb.Record.field_info)
  return field_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::neb::Field >*
Record::mutable_field_info() {
  // @@protoc_insertion_point(field_mutable_list:neb.Record.field_info)
  return &field_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::neb::Field >&
Record::field_info() const {
  // @@protoc_insertion_point(field_list:neb.Record.field_info)
  return field_info_;
}

// -------------------------------------------------------------------

// Field

// optional string col_name = 1;
inline void Field::clear_col_name() {
  col_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Field::col_name() const {
  // @@protoc_insertion_point(field_get:neb.Field.col_name)
  return col_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Field::set_col_name(const ::std::string& value) {
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Field.col_name)
}
inline void Field::set_col_name(const char* value) {
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Field.col_name)
}
inline void Field::set_col_name(const char* value, size_t size) {
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Field.col_name)
}
inline ::std::string* Field::mutable_col_name() {
  
  // @@protoc_insertion_point(field_mutable:neb.Field.col_name)
  return col_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Field::release_col_name() {
  // @@protoc_insertion_point(field_release:neb.Field.col_name)
  
  return col_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Field::set_allocated_col_name(::std::string* col_name) {
  if (col_name != NULL) {
    
  } else {
    
  }
  col_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), col_name);
  // @@protoc_insertion_point(field_set_allocated:neb.Field.col_name)
}

// optional .neb.E_COL_TYPE col_type = 2;
inline void Field::clear_col_type() {
  col_type_ = 0;
}
inline ::neb::E_COL_TYPE Field::col_type() const {
  // @@protoc_insertion_point(field_get:neb.Field.col_type)
  return static_cast< ::neb::E_COL_TYPE >(col_type_);
}
inline void Field::set_col_type(::neb::E_COL_TYPE value) {
  
  col_type_ = value;
  // @@protoc_insertion_point(field_set:neb.Field.col_type)
}

// optional bytes col_value = 3;
inline void Field::clear_col_value() {
  col_value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Field::col_value() const {
  // @@protoc_insertion_point(field_get:neb.Field.col_value)
  return col_value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Field::set_col_value(const ::std::string& value) {
  
  col_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Field.col_value)
}
inline void Field::set_col_value(const char* value) {
  
  col_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Field.col_value)
}
inline void Field::set_col_value(const void* value, size_t size) {
  
  col_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Field.col_value)
}
inline ::std::string* Field::mutable_col_value() {
  
  // @@protoc_insertion_point(field_mutable:neb.Field.col_value)
  return col_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Field::release_col_value() {
  // @@protoc_insertion_point(field_release:neb.Field.col_value)
  
  return col_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Field::set_allocated_col_value(::std::string* col_value) {
  if (col_value != NULL) {
    
  } else {
    
  }
  col_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), col_value);
  // @@protoc_insertion_point(field_set_allocated:neb.Field.col_value)
}

// optional string col_as = 4;
inline void Field::clear_col_as() {
  col_as_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Field::col_as() const {
  // @@protoc_insertion_point(field_get:neb.Field.col_as)
  return col_as_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Field::set_col_as(const ::std::string& value) {
  
  col_as_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Field.col_as)
}
inline void Field::set_col_as(const char* value) {
  
  col_as_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Field.col_as)
}
inline void Field::set_col_as(const char* value, size_t size) {
  
  col_as_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Field.col_as)
}
inline ::std::string* Field::mutable_col_as() {
  
  // @@protoc_insertion_point(field_mutable:neb.Field.col_as)
  return col_as_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Field::release_col_as() {
  // @@protoc_insertion_point(field_release:neb.Field.col_as)
  
  return col_as_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Field::set_allocated_col_as(::std::string* col_as) {
  if (col_as != NULL) {
    
  } else {
    
  }
  col_as_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), col_as);
  // @@protoc_insertion_point(field_set_allocated:neb.Field.col_as)
}

// -------------------------------------------------------------------

// Result_DataLocate

// optional uint32 section_from = 1;
inline void Result_DataLocate::clear_section_from() {
  section_from_ = 0u;
}
inline ::google::protobuf::uint32 Result_DataLocate::section_from() const {
  // @@protoc_insertion_point(field_get:neb.Result.DataLocate.section_from)
  return section_from_;
}
inline void Result_DataLocate::set_section_from(::google::protobuf::uint32 value) {
  
  section_from_ = value;
  // @@protoc_insertion_point(field_set:neb.Result.DataLocate.section_from)
}

// optional uint32 section_to = 2;
inline void Result_DataLocate::clear_section_to() {
  section_to_ = 0u;
}
inline ::google::protobuf::uint32 Result_DataLocate::section_to() const {
  // @@protoc_insertion_point(field_get:neb.Result.DataLocate.section_to)
  return section_to_;
}
inline void Result_DataLocate::set_section_to(::google::protobuf::uint32 value) {
  
  section_to_ = value;
  // @@protoc_insertion_point(field_set:neb.Result.DataLocate.section_to)
}

// optional uint32 hash = 3;
inline void Result_DataLocate::clear_hash() {
  hash_ = 0u;
}
inline ::google::protobuf::uint32 Result_DataLocate::hash() const {
  // @@protoc_insertion_point(field_get:neb.Result.DataLocate.hash)
  return hash_;
}
inline void Result_DataLocate::set_hash(::google::protobuf::uint32 value) {
  
  hash_ = value;
  // @@protoc_insertion_point(field_set:neb.Result.DataLocate.hash)
}

// optional uint32 divisor = 4;
inline void Result_DataLocate::clear_divisor() {
  divisor_ = 0u;
}
inline ::google::protobuf::uint32 Result_DataLocate::divisor() const {
  // @@protoc_insertion_point(field_get:neb.Result.DataLocate.divisor)
  return divisor_;
}
inline void Result_DataLocate::set_divisor(::google::protobuf::uint32 value) {
  
  divisor_ = value;
  // @@protoc_insertion_point(field_set:neb.Result.DataLocate.divisor)
}

// -------------------------------------------------------------------

// Result

// optional int32 err_no = 1;
inline void Result::clear_code() {
  err_no_ = 0;
}
inline ::google::protobuf::int32 Result::code() const {
  // @@protoc_insertion_point(field_get:neb.Result.err_no)
  return err_no_;
}
inline void Result::set_code(::google::protobuf::int32 value) {
  
  err_no_ = value;
  // @@protoc_insertion_point(field_set:neb.Result.err_no)
}

// optional bytes err_msg = 2;
inline void Result::clear_msg() {
  err_msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Result::msg() const {
  // @@protoc_insertion_point(field_get:neb.Result.err_msg)
  return err_msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Result::set_msg(const ::std::string& value) {
  
  err_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:neb.Result.err_msg)
}
inline void Result::set_msg(const char* value) {
  
  err_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:neb.Result.err_msg)
}
inline void Result::set_msg(const void* value, size_t size) {
  
  err_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:neb.Result.err_msg)
}
inline ::std::string* Result::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:neb.Result.err_msg)
  return err_msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Result::release_msg() {
  // @@protoc_insertion_point(field_release:neb.Result.err_msg)
  
  return err_msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Result::set_allocated_msg(::std::string* err_msg) {
  if (err_msg != NULL) {
    
  } else {
    
  }
  err_msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), err_msg);
  // @@protoc_insertion_point(field_set_allocated:neb.Result.err_msg)
}

// optional int32 total_count = 3;
inline void Result::clear_total_count() {
  total_count_ = 0;
}
inline ::google::protobuf::int32 Result::total_count() const {
  // @@protoc_insertion_point(field_get:neb.Result.total_count)
  return total_count_;
}
inline void Result::set_total_count(::google::protobuf::int32 value) {
  
  total_count_ = value;
  // @@protoc_insertion_point(field_set:neb.Result.total_count)
}

// optional int32 current_count = 4;
inline void Result::clear_current_count() {
  current_count_ = 0;
}
inline ::google::protobuf::int32 Result::current_count() const {
  // @@protoc_insertion_point(field_get:neb.Result.current_count)
  return current_count_;
}
inline void Result::set_current_count(::google::protobuf::int32 value) {
  
  current_count_ = value;
  // @@protoc_insertion_point(field_set:neb.Result.current_count)
}

// repeated .neb.Record record_data = 5;
inline int Result::record_data_size() const {
  return record_data_.size();
}
inline void Result::clear_record_data() {
  record_data_.Clear();
}
inline const ::neb::Record& Result::record_data(int index) const {
  // @@protoc_insertion_point(field_get:neb.Result.record_data)
  return record_data_.Get(index);
}
inline ::neb::Record* Result::mutable_record_data(int index) {
  // @@protoc_insertion_point(field_mutable:neb.Result.record_data)
  return record_data_.Mutable(index);
}
inline ::neb::Record* Result::add_record_data() {
  // @@protoc_insertion_point(field_add:neb.Result.record_data)
  return record_data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::neb::Record >*
Result::mutable_record_data() {
  // @@protoc_insertion_point(field_mutable_list:neb.Result.record_data)
  return &record_data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::neb::Record >&
Result::record_data() const {
  // @@protoc_insertion_point(field_list:neb.Result.record_data)
  return record_data_;
}

// optional int32 from = 6;
inline void Result::clear_from() {
  from_ = 0;
}
inline ::google::protobuf::int32 Result::from() const {
  // @@protoc_insertion_point(field_get:neb.Result.from)
  return from_;
}
inline void Result::set_from(::google::protobuf::int32 value) {
  
  from_ = value;
  // @@protoc_insertion_point(field_set:neb.Result.from)
}

// optional .neb.Result.DataLocate locate = 7;
inline bool Result::has_locate() const {
  return !_is_default_instance_ && locate_ != NULL;
}
inline void Result::clear_locate() {
  if (GetArenaNoVirtual() == NULL && locate_ != NULL) delete locate_;
  locate_ = NULL;
}
inline const ::neb::Result_DataLocate& Result::locate() const {
  // @@protoc_insertion_point(field_get:neb.Result.locate)
  return locate_ != NULL ? *locate_ : *default_instance_->locate_;
}
inline ::neb::Result_DataLocate* Result::mutable_locate() {
  
  if (locate_ == NULL) {
    locate_ = new ::neb::Result_DataLocate;
  }
  // @@protoc_insertion_point(field_mutable:neb.Result.locate)
  return locate_;
}
inline ::neb::Result_DataLocate* Result::release_locate() {
  // @@protoc_insertion_point(field_release:neb.Result.locate)
  
  ::neb::Result_DataLocate* temp = locate_;
  locate_ = NULL;
  return temp;
}
inline void Result::set_allocated_locate(::neb::Result_DataLocate* locate) {
  delete locate_;
  locate_ = locate;
  if (locate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:neb.Result.locate)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace neb

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::neb::Storage_RedisOperate_OPERATE_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::neb::Storage_RedisOperate_OPERATE_TYPE>() {
  return ::neb::Storage_RedisOperate_OPERATE_TYPE_descriptor();
}
template <> struct is_proto_enum< ::neb::Storage_DbOperate_Condition_E_RELATION> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::neb::Storage_DbOperate_Condition_E_RELATION>() {
  return ::neb::Storage_DbOperate_Condition_E_RELATION_descriptor();
}
template <> struct is_proto_enum< ::neb::Storage_DbOperate_ConditionGroup_E_RELATION> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::neb::Storage_DbOperate_ConditionGroup_E_RELATION>() {
  return ::neb::Storage_DbOperate_ConditionGroup_E_RELATION_descriptor();
}
template <> struct is_proto_enum< ::neb::Storage_DbOperate_OrderBy_E_RELATION> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::neb::Storage_DbOperate_OrderBy_E_RELATION>() {
  return ::neb::Storage_DbOperate_OrderBy_E_RELATION_descriptor();
}
template <> struct is_proto_enum< ::neb::Storage_DbOperate_E_QUERY_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::neb::Storage_DbOperate_E_QUERY_TYPE>() {
  return ::neb::Storage_DbOperate_E_QUERY_TYPE_descriptor();
}
template <> struct is_proto_enum< ::neb::Result_E_RESULT_FROM> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::neb::Result_E_RESULT_FROM>() {
  return ::neb::Result_E_RESULT_FROM_descriptor();
}
template <> struct is_proto_enum< ::neb::E_COL_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::neb::E_COL_TYPE>() {
  return ::neb::E_COL_TYPE_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_storage_2eproto__INCLUDED
